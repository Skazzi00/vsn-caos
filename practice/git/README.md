# Система контроля версий Git

Git — распределённая система контроля версий, позволяющая хранить историю изменений в проекте, работать в ветках и обмениваться изменениями с удалёнными репозиториями.

## Инициализация и базовые команды

Создание нового репозитория в текущем каталоге:

```
> git init
Initialized empty Git repository in /path/to/project/.git/
```

После инициализации в каталоге появляется скрытая папка `.git`, в которой хранятся объекты репозитория и служебная информация.

Проверить состояние рабочего каталога и индекса:

```
> git status
On branch main
Untracked files:
  hello.c
  README.md
```

Добавить файлы в индекс (staging area) перед коммитом:

```
> git add hello.c README.md
# или добавить все изменённые и новые файлы
> git add .
```

Зафиксировать изменения в истории:

```
> git commit -m "Add hello world and README"
[main 1a2b3c4] Add hello world and README
 2 files changed, 25 insertions(+)
 create mode 100644 hello.c
 create mode 100644 README.md
```

Сообщение коммита можно не указывать в командной строке: тогда откроется редактор (значение переменной окружения `EDITOR` или `GIT_EDITOR`).

Просмотр истории коммитов — см. раздел [Журнал коммитов (git log)](#журнал-коммитов-git-log) ниже.

## Клонирование и удалённые репозитории

Получить копию существующего репозитория:

```
> git clone https://example.com/repo.git my-project
Cloning into 'my-project'...
```

По умолчанию создаётся удалённый репозиторий с именем `origin`, указывающий на URL клонирования.

Просмотр настроенных удалённых репозиториев:

```
> git remote -v
origin  https://example.com/repo.git (fetch)
origin  https://example.com/repo.git (push)
```

Отправка локальных коммитов в удалённый репозиторий:

```
> git push origin main
```

Получение изменений из удалённого репозитория (без слияния в текущую ветку):

```
> git fetch origin
```

Слияние полученных изменений в текущую ветку:

```
> git pull origin main
```

Команда `git pull` эквивалентна последовательности `git fetch` и `git merge` для указанной ветки.

## Ветки

Ветка — указатель на один из коммитов. По умолчанию основная ветка часто называется `main` или `master`.

Список локальных веток:

```
> git branch
* main
  feature-xyz
```

Создание новой ветки:

```
> git branch feature-xyz
```

Переключение на ветку:

```
> git checkout feature-xyz
# или
> git switch feature-xyz
```

Создание ветки и немедленное переключение на неё:

```
> git checkout -b feature-xyz
# или
> git switch -c feature-xyz
```

Слияние ветки в текущую:

```
> git checkout main
> git merge feature-xyz
```

### Rebase

Rebase переносит коммиты текущей ветки на верх другой ветки, переписывая историю: коммиты воспроизводятся по одному поверх указанной базы. В результате история становится линейной.

Перенести коммиты текущей ветки на верх `main`:

```
> git checkout feature-xyz
> git rebase main
```

Если конфликтов нет, ветка `feature-xyz` будет указывать на новые коммиты, построенные поверх актуального `main`. При конфликтах Git останавливается; после правки файлов нужно выполнить `git add` и `git rebase --continue`. Отменить rebase до завершения: `git rebase --abort`.

Интерактивный rebase позволяет переписывать, объединять или удалять коммиты:

```
> git rebase -i HEAD~3
```

Откроется редактор со списком последних трёх коммитов и действиями (`pick`, `reword`, `squash`, `drop` и др.). Сохранение и выход применяют изменения.

**Важно:** не делайте rebase коммитов, которые уже отправлены в общий репозиторий (или договоритесь с командой). Rebase меняет хеши коммитов; после перезаписи истории потребуется принудительная отправка `git push --force`, что затрудняет работу остальных.

## Отмена изменений

Отменить изменения в рабочем копии файла (вернуть к состоянию последнего коммита или индекса):

```
> git checkout -- hello.c
# или (новый вариант)
> git restore hello.c
```

Убрать файл из индекса, оставив изменения в файле:

```
> git reset HEAD hello.c
# или
> git restore --staged hello.c
```

Изменить последний коммит (добавить файлы в индекс и перезаписать сообщение или содержимое коммита):

```
> git add forgotten.c
> git commit --amend -m "Updated message"
```

Использовать `--amend` только для коммитов, которые ещё не были отправлены в общий репозиторий.

## Просмотр изменений

Разница между рабочей копией и индексом:

```
> git diff
```

Разница между индексом и последним коммитом:

```
> git diff --staged
```

Разница между двумя коммитами:

```
> git diff 1a2b3c4 5e6f789
```

Просмотр содержимого файла на момент заданного коммита:

```
> git show 1a2b3c4:path/to/file.c
```

## Журнал коммитов (git log)

Полный вывод по каждому коммиту (автор, дата, сообщение):

```
> git log
commit 1a2b3c4d5e6f7890abcdef1234567890abcdef12
Author: Name <user@example.com>
Date:   Thu Feb 26 12:00:00 2025 +0300

    Add hello world and README
```

Краткий однострочный формат:

```
> git log --oneline
1a2b3c4 Add hello world and README
0f9e8d7 Initial commit
```

Граф веток (удобно при нескольких ветках):

```
> git log --oneline --graph --all
* 1a2b3c4 (HEAD -> main) Add hello world and README
* 0f9e8d7 Initial commit
```

Ограничить количество коммитов:

```
> git log -n 5 --oneline
```

Показать патч (diff) для каждого коммита:

```
> git log -p
```

Поиск коммитов, в которых менялась строка с заданным текстом:

```
> git log -S "function_name" --oneline
```

Просмотр истории одного файла:

```
> git log -- path/to/file.c
```

## Reflog

Reflog — журнал перемещений указателей (HEAD, веток): куда указывал HEAD и ветки при каждом действии (commit, checkout, merge, rebase и т.д.). Полезен для восстановления «потерянных» коммитов после ошибочного `reset` или после rebase.

Просмотр reflog текущей ветки (по умолчанию — HEAD):

```
> git reflog
1a2b3c4 (HEAD -> main) HEAD@{0}: commit: Add hello world and README
0f9e8d7 HEAD@{1}: checkout: moving from feature to main
2b3c4d5 HEAD@{2}: commit: WIP feature
```

Reflog для конкретной ветки:

```
> git reflog main
```

Восстановить ветку на коммит, который виден только в reflog:

```
> git reset --hard HEAD@{2}
```

Записи reflog со временем удаляются (по умолчанию неиспользуемые — примерно через 90 дней). До удаления любой коммит из reflog можно вернуть.

## Игнорирование файлов

Файл `.gitignore` в корне репозитория задаёт шаблоны файлов и каталогов, которые Git не отслеживает.

Пример:

```
# объектные файлы
*.o
*.a

# каталог сборки
build/
cmake-build-*/

# локальные настройки
.env
*.local
```

Строки, начинающиеся с `#`, считаются комментариями. Поддерживаются шаблоны в стиле shell (например, `*`, `?`, `[a-z]`).

## Краткая справка

| Действие              | Команда |
| --------------------- | ------- |
| Инициализация         | `git init` |
| Статус                | `git status` |
| Добавить в индекс     | `git add <файлы>` |
| Коммит                | `git commit -m "сообщение"` |
| История               | `git log`, `git log --oneline`, `git log --graph --all` |
| Reflog                | `git reflog`, `git reset --hard HEAD@{n}` |
| Rebase                | `git rebase <ветка>`, `git rebase -i HEAD~n` |
| Клонирование          | `git clone <url>` |
| Отправка              | `git push <remote> <ветка>` |
| Получение и слияние   | `git pull <remote> <ветка>` |
| Ветки                 | `git branch`, `git checkout`, `git switch` |
| Слияние ветки         | `git merge <ветка>` |

Подробное описание команд и опций: `man git-<команда>` или [документация Git](https://git-scm.com/doc).
